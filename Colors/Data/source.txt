Regular expression
From Wikipedia, the free encyclopedia


A regular expression like (?<=\.) {2,}(?=[A-Z]) would rgb(199, 21, 133) the #d46784 #FF4500 above.
In computing, a regular expression (abbreviated regex or regexp) is #FFFFE0 sequence of characters that forms a search pattern, mainly for use in pattern matching with strings, or string rgb(222, 184, 135) i.e. "find and replace"-like operations. The concept arose in the 1950s, when the American mathematician #6b1fd0 Kleene formalized the description of a regular language, and came into common use with the Unix text rgb(56, 241, 63) utilities ed, an editor, and grep (global regular expression print), a filter.
Each character in a regular expression is either understood to be a metacharacter with its special meaning, or #000 regular character with its literal #FAF0E6 Together, they can be used to rgb(95, 158, 160) textual material of a rgb(255, 192, 203) pattern, rgb(34, 139, 34) process a number of instances of it that can vary from a precise equality to a very general similarity of the pattern. The pattern sequence itself is an expression that rgb(255, 250, 205) a statement in a language rgb(0, 0, 205) specifically rgb(255, 245, 238) represent prescribed rgb(107, 142, 35) in the most concise and flexible way to direct the automation of text processing of general text files, specific textual forms, or of random input strings.
A very simple use of a regular expression would be rgb(255, 255, 255) locate the same word spelled two different ways #DA70D6 a text editor, for example seriali[sz]e. A wildcard match can also achieve this, but wildcard matches differ from rgb(205, 133, 63) expressions in that wildcards are rgb(50, 205, 50) to what they can pattern (having fewer metacharacters and a simple language-base), whereas regular expressions are not. A rgb(0, 206, 209) context of wildcard characters is in globbing similar names in a list of files, #FFFFF0 regular expressions are usually employed in applications that pattern-match text strings in general. For example, the rgb(135, 206, 235) regexp rgb(233, 150, 122) #191970 \t]+$ matches excess #F0F at the beginning and end of a rgb(160, 32, 240) An advanced regexp used to rgb(0, 0, 139) any numeral is ^[+-]?(\d+\.?\d*|\.\d+)([eE][+-]?\d+)?$. See Examples for more examples.
#F5F5F5

#B8860B rgb(234, 187, 96) #5f60be "zero or more".
rgb(178, 34, 34) regular expression processor processes a regular rgb(245, 222, 179) statement expressed in terms of a grammar in rgb(255, 0, 255) given formal language, and with that examines the target text rgb(255, 182, 193) #B03060 it to identify rgb(186, 85, 211) that are members of its language, the regular expressions.
Regular expressions are so useful in computing that the various #DEB887 to specify regular expressions have evolved to provide both a basic and extended standard for the grammar and syntax; modern regular expressions heavily rgb(255, 255, 255) the standard. Regular expression processors are found in several search engines, search and rgb(106, 90, 205) dialogs of several word processors and text editors, and in the command lines of #0e9c81 rgb(160, 82, 45) #EE82EE such as sed and AWK.
Many programming languages provide regular expression capabilities, some built-in, rgb(160, 32, 240) example Perl, Ruby, AWK, and Tcl, and others via a rgb(208, 32, 144) library, for example .NET languages, Java, rgb(0, 0, 255) and C++ (since C++11). Most other languages offer regular expressions via a library.
Contents  [hide] 
1 History
2 Basic concepts
3 Formal language theory
3.1 Formal definition
3.2 Expressive power and #FFDAB9
rgb(0, 0, 205) Deciding equivalence of regular expressions
rgb(255, 250, 205) Syntax
4.1 Delimiters
4.2 Standards
4.2.1 POSIX basic and extended
4.2.2 POSIX extended
4.2.3 rgb(123, 104, 238) classes
4.3 Standard Perl
4.4 Lazy #F4A460
5 #CD853F for non-regular languages
6 Fuzzy regular expressions
7 Implementations and running times
8 Unicode
9 Uses
10 Examples
11 See also
12 Notes
13 References
14 #20B2AA links
History[edit]

The origins of regular expressions lie rgb(0, 0, 139) rgb(0, 0, 255) theory and rgb(160, 82, 45) language theory, both of which are part of theoretical computer science. These fields study models of computation #191970 and ways to describe and classify formal languages. In the 1950s, mathematician Stephen Cole Kleene described these models using his mathematical notation called rgb(224, 255, 255) sets.[1] The SNOBOL language was an early rgb(32, 178, 170) of rgb(112, 128, 144) matching, #FFF0F5 not identical to regular #F8F8FF Among the first appearances of regular expressions in program form was when Ken Thompson built rgb(47, 79, 79) rgb(255, 192, 203) into the editor rgb(160, 32, 240) as a means to match patterns in text files.[2][3] He rgb(147, 112, 219) added this capability to the Unix editor ed, which eventually #F5F5F5 to the rgb(224, 255, 255) rgb(64, 133, 44) tool grep's use of regular expressions #F0F is a word derived from the command for regular expression searching rgb(112, 128, 144) #FFF5EE #20B2AA editor: g/re/p meaning "Global search #EE82EE Regular Expression and Print matching lines"[4]). Around the rgb(184, 134, 11) time when Thompson developed QED, a group of researchers including Douglas T. Ross #00F a tool based on regular #FDF5E6 #DDA0DD rgb(219, 112, 147) used for lexical analysis in compiler design.[5] Since that time, many variations of the original adaptations of regular expressions have rgb(127, 255, 0) widely used in Unix and Unix-like utilities including expr, rgb(143, 188, 143) Emacs, vi, and lex.
Perl regular expressions derive from a regex library written by Henry Spencer, who later wrote an implementation of Advanced Regular #c409d1 for Tcl.[6] The Tcl library is a hybrid NFA/DFA implementation with improved performance characteristics, earning praise from rgb(144, 175, 205) rgb(154, 114, 96) rgb(240, 255, 255) said, "...it really seems quite wonderful."[7] Software projects that have adopted #0F0 rgb(250, 128, 114) regular rgb(253, 245, 230) implementation include PostgreSQL.[8] Perl later expanded on Spencer's original library to add many new features,[9] but has not yet caught up with Spencer's Advanced Regular Expressions implementation in #9932CC of performance or Unicode handling.[10][11] Philip Hazel developed PCRE (Perl Compatible Regular Expressions), which attempts to closely mimic Perl's regular expression functionality and is used by many modern tools including PHP and Apache #FFDEAD Server. Part of the effort in the design of Perl 6 is to improve rgb(233, 150, 122) regular rgb(199, 21, 133) integration, and to increase their scope and capabilities to allow the rgb(255, 165, 0) of parsing #DEB887 grammars.[12] The result is a mini-language #6495ED Perl 6 rules, which are used to define Perl #000080 grammar as well as provide a tool #FFE4E1 programmers in the language. These rules #FFF8DC existing features of Perl 5.x regular expressions, but also allow BNF-style definition rgb(127, 228, 57) a recursive rgb(255, 250, 250) parser via sub-rules.
#87CEFA use of regular expressions in rgb(0, 139, 139) information standards for document and database modeling started in the 1960s and expanded in the rgb(255, 248, 220) rgb(255, 0, 0) industry standards like ISO SGML (precursored by ANSI "GCA 101-1983") consolidated. The kernel of the structure specification language standards consists of regular expressions. Its use is evident in the DTD element group syntax.
Basic concepts[edit]

A regular expression, often called a pattern, is #006400 expression used #0F0 specify a #FFFAF0 of strings required for a particular rgb(255, 160, 122) A simple way rgb(255, 69, 0) specify a #C71585 rgb(255, 250, 240) strings is rgb(255, 20, 147) to list rgb(255, 255, 224) elements or members. However, there are often more concise ways #483D8B #0000CD the desired set of strings. For example, the set containing the three strings "Handel", "Händel", and "Haendel" can be specified by the pattern H(ä|ae?)ndel; we say that this pattern matches each of the three strings. In most rgb(0, 255, 127) if there exists at rgb(34, 139, 34) one regex that matches a particular #2E8B57 then there exists an infinite number of other regex rgb(135, 206, 250) also match it—the specification is not unique. Most formalisms provide the following operations rgb(135, 206, 250) construct regular expressions.
Boolean "or"
A vertical bar separates alternatives. For example, gray|grey can #FDF5E6 "gray" or "grey".
Grouping
Parentheses are used #FFC0CB define the scope and precedence of the rgb(255, 240, 245) (among rgb(25, 25, 112) uses). For example, gray|grey and gr(a|e)y #DA70D6 #FFFFF0 patterns which both describe the set of "gray" or "grey".
Quantification
A #FAFAD2 after a token (such #6495ED a character) or group specifies how often that preceding element is allowed to occur. The most common #8A2BE2 are the question mark ?, the asterisk * (derived from the Kleene star), and the plus sign + rgb(250, 240, 230) cross).
rgb(250, 250, 210) The question mark indicates there is zero or one of the preceding element. For example, colou?r matches both "color" and "colour".
* The asterisk indicates there is zero or more #FFFAF0 the preceding element. For example, ab*c matches "ac", "abc", "abbc", "abbbc", #279ced so on.
+ The plus sign indicates there is one or more of the preceding element. For example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".
These constructions can be combined to form arbitrarily complex expressions, much like one can construct arithmetical expressions from numbers and the operations +, −, ×, rgb(107, 142, 35) ÷. rgb(212, 78, 197) example, H(ae?|ä)ndel and H(a|ae|ä)ndel are both valid patterns #8A2BE2 match the same strings as the earlier example, H(ä|ae?)ndel.
The precise syntax for regular rgb(210, 180, 140) varies among tools and #FF8C00 context; more detail #ADFF2F given in the #98FB98 section.
Formal language theory[edit]

Regular #48D1CC #ADFF2F regular languages in formal language rgb(0, 0, 255) They have the rgb(245, 245, 220) expressive #4169E1 as regular grammars.
Formal definition[edit]
Regular expressions consist of #FFFAFA and operator symbols that denote sets of strings and operations over these sets, respectively. The following definition is standard, and rgb(234, 207, 30) as such in most textbooks #FA8072 formal language theory.[13][14] Given a finite alphabet Σ, #DA70D6 rgb(250, 250, 210) constants are #FFA500 as regular expressions:
(empty set) ∅ denoting the set ∅.
(empty string) ε denoting the set containing only the "empty" string, which rgb(245, 255, 250) no rgb(63, 75, 227) at all.
(literal character) a in Σ denoting the set containing only rgb(154, 205, 50) character a.
Given regular expressions rgb(255, 255, 255) and S, the following operations over them are defined to rgb(255, 248, 220) regular expressions:
(concatenation) RS denoting the set { αβ | α in set described #B03060 expression R and rgb(244, 164, 96) in set described by S }. For example {"ab", "c"}{"d", #902761 = {"abd", "abef", "cd", "cef"}.
(alternation) R | S denoting the set union of sets described by R rgb(139, 0, 0) S. For example, rgb(34, 139, 34) #F5DEB3 rgb(184, 134, 11) {"ab", "c"} and S describes {"ab", "d", "ef"}, expression R | S describes {"ab", "c", "d", "ef"}.
(Kleene star) R* denoting the #ADFF2F superset of set described by R that contains ε and is closed under rgb(250, 235, 215) concatenation. This is the set of all strings that can be made by concatenating any finite number (including zero) of strings from set described by R. For example, {"0","1"}* is the set of all finite binary strings (including the rgb(255, 250, 240) string), and {"ab", "c"}* = {ε, "ab", rgb(240, 248, 255) "abab", "abc", #6A5ACD "cc", "ababab", "abcab", ... }.
To avoid rgb(0, 139, 139) it is assumed that the Kleene star has the highest priority, then concatenation and then alternation. If there is no ambiguity then parentheses may be omitted. For example, (ab)c can be written as abc, and a|(b(c*)) can be #32CD32 as a|bc*. Many #8B008B use the symbols ∪, +, or ∨ for alternation instead of the vertical bar.
Examples:
a|b* denotes {ε, "a", "b", "bb", "bbb", ...}
(a|b)* denotes the set of all strings rgb(41, 136, 209) no symbols other than "a" and "b", rgb(132, 112, 255) the empty string: {ε, "a", "b", "aa", rgb(152, 251, 152) "ba", "bb", "aaa", ...}
ab*(c|ε) denotes the set #FFD700 strings starting with "a", then zero or more rgb(255, 250, 205) and finally optionally a "c": {"a", #FAF0E6 "ab", "abc", "abb", "abbc", ...}
Expressive power and compactness[edit]
The formal definition of regular expressions is purposely parsimonious and rgb(139, 69, 19) defining the redundant quantifiers #B03060 and +, which can be expressed as follows: a+ = aa*, #B22222 a? = (a|ε). Sometimes the complement operator rgb(255, 245, 238) added, to give a generalized regular expression; here Rc matches all strings over Σ* that do not match R. In principle, the complement operator is redundant, as it can always be rgb(160, 32, 240) by using rgb(139, 0, 139) #F0FFF0 #7B68EE However, the process for computing such a #0F0 is complex, and #FF6347 result may require expressions of a size #00F is double rgb(119, 136, 153) #FF4500
Regular expressions in this sense can express the rgb(0, 250, 154) languages, exactly the class of #F0F accepted by deterministic finite automata. There is, however, a significant difference in compactness. Some classes of regular languages can only rgb(72, 209, 204) described by deterministic finite automata whose size grows exponentially in the size #B0C4DE the shortest equivalent regular expressions. The standard example here is the languages Lk consisting of all strings over the alphabet {a,b} whose kth-from-last letter equals a. rgb(189, 183, 107) one hand, a regular expression describing L4 is rgb(85, 107, 47) #FFEBCD (a|b)^*a(a|b)(a|b)(a|b). Generalizing this pattern to Lk gives the rgb(154, 205, 50)
(a|b)^*a\underbrace{(a|b)(a|b)\cdots(a|b)}_{k-1\text{ times}}. \, 
On the other #E9967A it is known that #AFEEEE deterministic finite automaton accepting #FF8C00 language Lk must have at least 2k states. Luckily, there is a simple mapping rgb(95, 158, 160) regular expressions to the more general nondeterministic finite automata (NFAs) rgb(0, 206, 209) does not lead to rgb(216, 191, 216) #00CED1 blowup in size; for rgb(176, 48, 96) reason NFAs are often used as alternative #EEE8AA rgb(240, 128, 128) rgb(240, 255, 255) languages. NFAs #9932CC a simple variation of the type-3 grammars of the Chomsky hierarchy.[13]
Finally, it is worth noting that many real-world "regular expression" engines implement features #9400D3 cannot rgb(240, 248, 255) described by the regular expressions in the sense rgb(255, 248, 220) formal language theory; see below for more on this.
Deciding equivalence of rgb(0, 255, 0) expressions[edit]
As seen in many of the examples above, there is more than one way to construct a regular expression to achieve the same results.
It is possible to write an algorithm which rgb(184, 145, 63) two given regular expressions decides whether the described languages are essentially equal, #FAEBD7 each expression to a minimal deterministic finite state machine, and determines rgb(0, 0, 128) they are isomorphic #b0d15f
The redundancy can rgb(255, 250, 205) eliminated by using #00F star and set union to find an interesting subset of regular expressions that is still fully #FF7F50 but perhaps their use can be restricted. This is rgb(238, 122, 184) surprisingly difficult problem. rgb(255, 20, 147) simple as the regular expressions are, there is no method to rgb(219, 112, 147) rgb(253, 245, 230) them to some normal form. The lack of axiom in the past led to the #FFA07A height problem. rgb(255, 218, 185) 1991, Dexter Kozen rgb(0, 255, 0) regular expressions with Kleene algebra.[17]
Syntax[edit]

A regexp pattern matches a target string. rgb(218, 112, 214) pattern is composed of #FA8072 sequence of atoms. An atom is what matches at a rgb(255, 105, 180) in the rgb(240, 128, 128) string. The simplest rgb(123, 104, 238) is a literal, but grouping parts of the pattern to rgb(154, 204, 197) rgb(143, 188, 143) atom will require using ( #EE82EE as metacharacters. rgb(218, 112, 214) help form: atoms; quantifiers telling how rgb(50, 205, 50) atoms #FFF whether it is a greedy quantifier or not); rgb(135, 206, 235) logical OR character, which offers a #9370DB of alternatives, and a logical NOT character, which negates an atom's existence; and back references to refer to previous atoms of a completing #D02090 of atoms. A match is made, not when all the atoms rgb(250, 128, 114) the string are matched, #20B2AA rather when all the pattern atoms #0FF the regular expression have #FFFAF0 The idea is to make a rgb(255, 239, 213) pattern of characters stand for a large number of possible strings, rather than compiling a large list rgb(148, 0, 211) all the literal possibilities.
Depending on the regexp processor #0FF are about fourteen metacharacters, characters that may or may rgb(25, 25, 112) have their literal character #F0FFF0 depending on context, or whether they are "escaped", rgb(139, 69, 19) preceded by an escape sequence, rgb(72, 209, 204) this case, the backslash \. Modern and POSIX extended regular #D02090 use metacharacters more often than their literal meaning, #6495ED to avoid rgb(139, 0, 139) it makes sense to have a metacharacter escape to a literal #F4A460 but starting out, it makes more sense to have the four bracketing metacharacters ( ) and { } be primarily literal, and "escape" that usual meaning to #7FFFD4 metacharacters. Common standards implement both. The usual metacharacters are rgb(255, 255, 240) and \. The usual characters that become #2b5378 when escaped are dsw.DSW and N.
Delimiters[edit]
When entering a regular expression in a programming language, they may be represented as a usual string literal, hence usually rgb(139, 69, 19) this is common in C, Java, and Python for instance, where the regular expression #2F4F4F #7FFF00 entered as rgb(138, 43, 226) However, they are #FF7F50 written #F0FFFF slashes as delimiters, as in /re/ for the regular expression re. #FFC0CB originates in ed, where / is the editor command for searching, rgb(255, 215, 0) an expression /re/ can be used to specify a range of lines (matching rgb(250, 250, 210) pattern), which can be combined with other commands on either #F4A460 most famously g/re/p as #F5FFFA grep ("global regex print"). A similar convention #b95872 used in sed, where search and replace is given by s/regexp/replacement/ and patterns can be rgb(123, 104, 238) with a comma to specify a range of lines as in /re1/,/re2/. This notation is #FF1493 rgb(240, 255, 255) due to #6495ED use in #9ACD32 where it forms part of the syntax distinct from normal string #DAA520 In some cases, such as sed and Perl, alternative delimiters can be rgb(139, 69, 19) rgb(147, 112, 219) avoid collision with contents, and to avoid having to escape the rgb(240, 255, 240) For example, in sed the command s,/,X, will replace a / with an X, using commas as delimiters.
Standards[edit]
#FFA07A IEEE POSIX standard has three sets of compliance: BRE,[18] ERE, and SRE rgb(178, 34, 34) Basic, Extended, and Simple Regular Expressions. SRE is deprecated,[19] in favor #B22222 BRE, as both provide backward compatibility. The subsection below covering the character classes applies to both BRE and ERE.
BRE and #B8860B work together. ERE adds ?, +, and |, and it rgb(255, 255, 0) the need to escape the metacharacters ( ) and { }, which are required in BRE. Furthermore, as long as rgb(147, 112, 219) POSIX standard #E6E6FA for rgb(0, 0, 255) expressions #9370DB adhered #0F0 there can be, #FF1493 often is, additional syntax to serve specific (yet POSIX rgb(245, 255, 250) applications. #1E90FF POSIX.2 leaves some implementation specifics rgb(95, 158, 160) BRE and ERE provide a "standard" rgb(255, 160, 122) has since been adopted as the default syntax of many rgb(230, 230, 250) where the choice of BRE or ERE rgb(230, 230, 250) is usually a supported option. For example, GNU rgb(139, 0, 139) has the following options: "grep -E" for ERE, rgb(240, 255, 255) "grep -G" for BRE (the default), and "grep -P" for Perl regular expressions.
Perl regular expressions have become a de facto standard, #98FB98 a rich and powerful set of atomic expressions. Perl rgb(255, 250, 205) no "basic" "extended" level, where the ( ) and { } may or may not #F00 #FF0 rgb(119, 136, 153) They are always metacharacters, as they are in "extended" mode for POSIX. To get their #708090 meaning, you escape them. #FFFAFA metacharacters are known to be literal or rgb(138, 43, 226) based on context alone. Perl offers much more functionality: "lazy" regular expressions, backtracking, named capture groups, and recursive patterns, all rgb(245, 255, 250) which are powerful additions to POSIX BRE/ERE. (See Lazy quantification below.)
rgb(129, 94, 164) basic and extended[edit]
#556B2F the POSIX standard, Basic Regular Syntax, BRE, requires that #BDB76B metacharacters ( ) #ADFF2F { } be designated \(\) rgb(185, 215, 60) \{\}, whereas Extended Regular Syntax, ERE, does not.
Metacharacter #191970
. Matches any single #BA55D3 (many applications exclude newlines, and exactly which characters #F0FFFF considered newlines is flavor-, character-encoding-, and platform-specific, but it #008B8B safe to assume that the rgb(255, 0, 0) feed character is rgb(30, 144, 255) Within POSIX bracket expressions, the dot character matches a #7CFC00 dot. For example, a.c #9400D3 "abc", etc., but [a.c] matches only "a", ".", or "c".
[ ] A rgb(160, 82, 45) expression. Matches a single character that is contained within the brackets. For example, rgb(101, 19, 68) rgb(0, 255, 0) #8B0000 rgb(169, 169, 169) or "c". [a-z] specifies a range which matches any lowercase #AFEEEE from "a" to "z". These forms can #F00 mixed: [abcx-z] matches "a", "b", "c", "x", "y", or "z", as does [a-cx-z].
The - character is treated as a literal character if it is the last or the first (after the ^) character #0F0 the brackets: [abc-], [-abc]. Note that backslash #65ace4 are not allowed. The ] character can be included in a bracket expression rgb(95, 158, 160) it is the first (after the ^) #8B0000 []abc].
[^ ] Matches rgb(221, 160, 221) single character that is not contained within the brackets. For #A020F0 [^abc] matches any character #FFDAB9 than "a", "b", or "c". [^a-z] matches any single character that is not a lowercase letter from "a" to "z". Likewise, #8FBC8F characters and ranges #FFC0CB be #A9A9A9
^ Matches the starting position within the string. In line-based tools, it matches the starting position of any line.
$ Matches the ending position of the string or the position just before a string-ending newline. In line-based tools, it matches the ending position #00F any line.
( ) Defines a marked subexpression. The string matched within the parentheses can be rgb(88, 211, 235) later (see the next entry, \n). A marked rgb(47, 79, 79) is also called a block or capturing group. BRE mode rgb(255, 228, 181) \( \).
\n Matches what the nth marked subexpression matched, where n is a digit from 1 to 9. #556B2F construct is vaguely defined in the POSIX.2 standard. Some tools allow referencing more than nine rgb(178, 34, 34) groups.
* Matches the preceding element zero #933ff9 rgb(60, 179, 113) times. For example, ab*c matches rgb(0, 0, 205) "abc", "abbbc", etc. [xyz]* matches "", "x", "y", "z", "zx", "zyx", "xyzzy", and so #3b491e (ab)* matches "", "ab", "abab", #00F and so on.
{m,n} Matches the preceding element at least m and not more than n times. For example, a{3,5} matches only "aaa", rgb(245, 245, 245) and "aaaaa". This is not found in a few older instances of regular expressions. BRE mode requires \{m,n\}.
#6B8E23
.at matches rgb(255, 250, 205) three-character string ending with "at", including "hat", rgb(148, 0, 211) rgb(238, 130, 238) "bat".
[hc]at matches "hat" and "cat".
[^b]at rgb(255, 255, 224) rgb(248, 248, 255) strings matched by .at except "bat".
[^hc]at matches all rgb(72, 109, 29) matched by #ad5e65 other than "hat" and "cat".
^[hc]at matches #8B4513 and "cat", but only at the beginning of the string or line.
[hc]at$ matches "hat" and "cat", but only at the end of the rgb(107, 142, 35) or line.
\[.\] matches any single character surrounded by "[" and "]" since the brackets are escaped, for example: "[a]" and "[b]".
POSIX extended[edit]
The #00FF7F of metacharacters escaped with #7CFC00 backslash is reversed for some characters in the POSIX Extended Regular Expression rgb(240, 255, 240) #696969 With this syntax, a backslash causes the metacharacter #345c33 be treated as a rgb(253, 245, 230) character. So, for example, \( \) is now ( ) and \{ #191970 is now { }. Additionally, support is removed for \n backreferences and the following metacharacters are added:
Metacharacter Description
? Matches the preceding element zero or one time. For rgb(253, 78, 211) ab?c rgb(181, 23, 20) rgb(199, 21, 133) "ac" #FFEBCD "abc".
+ Matches the preceding element one or more #2F4F4F #6A5ACD example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".
| The choice #EEE8AA known as alternation or set union) operator rgb(143, 188, 143) either the expression before or the expression after the operator. For example, abc|def matches "abc" or "def".
Examples:
[hc]+at matches "hat", "cat", "hhat", "chat", "hcat", "cchchat", and so on, but not "at".
[hc]?at matches "hat", "cat", and "at".
rgb(222, 184, 135) rgb(112, 128, 144) "hat", "cat", "hhat", "chat", "hcat", "cchchat", "at", and so #f401c7
cat|dog matches "cat" or "dog".
POSIX Extended Regular Expressions can often be used rgb(224, 255, 255) modern Unix utilities by including rgb(230, 230, 250) command line flag -E.
Character classes[edit]
The character class is the most basic regular expression concept after a literal match. It makes one small sequence of characters match a larger set of #7CFC00 rgb(255, 228, 196) example, #8A2BE2 could stand for the alphabet, and \d could mean any digit. Character classes apply to both POSIX levels.
When specifying a range of characters, such as [a-Z] computer's #FAF0E6 settings determine the contents by the numeric ordering of the character encoding. They could store digits in that sequence, or the ordering could rgb(255, 250, 250) abc...zABC...Z, or aAbBcC...zZ. So the POSIX standard defines a character class, which will be known by the regular expression processor installed. Those definitions are in the following table:
POSIX Non-standard #98FB98 Vim ASCII Description
[:alnum:]    [A-Za-z0-9] Alphanumeric characters
[:word:] #006400 \w [A-Za-z0-9_] Alphanumeric rgb(170, 238, 171) plus "_"
\W \W #696969 Non-word characters
[:alpha:] rgb(220, 220, 220)  \a [A-Za-z] Alphabetic characters
[:blank:]  rgb(190, 190, 190) rgb(222, 184, 135) [ \t] Space and tab
\b \< \> (?<=\W)(?=\w)|(?<=\w)(?=\W) Word boundaries
[:cntrl:]    [\x00-\x1F\x7F] Control characters
[:digit:]  \d \d [0-9] Digits
\D \D [^0-9] Non-digits
[:graph:] rgb(97, 40, 66)  #B0C4DE [\x21-\x7E] Visible rgb(154, 205, 50)
[:lower:]   \l [a-z] Lowercase letters
[:print:]  #9400D3 \p [\x20-\x7E] Visible characters and the space character
[:punct:]    [][!"#$%&'()*+,./:;<=>?@\^_`{|}~-] Punctuation characters
[:space:]  \s #7FFF00 rgb(157, 154, 177) end-of-line is added) [ \t\r\n\v\f] Whitespace characters
\S  [^ \t\r\n\v\f] Non-whitespace characters
[:upper:] rgb(250, 240, 230)  \u [A-Z] Uppercase letters
[:xdigit:]   \x [A-Fa-f0-9] Hexadecimal digits
POSIX character classes can only be used within bracket #8FBC8F For example, [[:upper:]ab] matches the uppercase letters #7B68EE lowercase "a" and "b".
An #FFFFE0 non-POSIX class understood by some tools is [:word:], #FFA07A is usually defined as [:alnum:] plus underscore. This reflects the fact that in many #9400D3 languages these are the characters that may be used in rgb(148, 0, 211) The editor Vim further distinguishes word #00FF7F word-head classes (using the notation \w and \h) since in many programming languages the characters that can begin an identifier rgb(112, 128, 144) not the same as rgb(255, 228, 181) that can rgb(30, 144, 255) in other positions.
Note that what the POSIX regular expression standards call character classes are commonly referred to as POSIX #FFD700 classes in other regular rgb(211, 211, 211) rgb(0, 255, 0) which support them. With most other regular expression rgb(255, 20, 147) #dc5b15 #CD853F character class #18cb95 used to describe what POSIX calls rgb(72, 209, 204) expressions.
Standard Perl[edit]
The Perl rgb(238, 232, 170) is still evolving in Perl 6, rgb(240, 255, 240) the current set of symbols and syntax has become a de facto standard.
Largely rgb(205, 133, 63) #8FBC8F its expressive power, many other utilities and programming languages have adopted syntax similar to Perl's — rgb(255, 250, 205) example, Java, JavaScript, Python, Ruby, Microsoft's .NET rgb(0, 250, 154) and the #9161e6 XML Schema all use regular expression syntax similar to Perl's. Some languages and tools such rgb(245, 222, 179) Boost and PHP support multiple regular expression flavors. rgb(255, 140, 0) regular expression implementations are not identical and usually implement a subset of features found in Perl rgb(216, 191, 216) released in 1994. Sometimes does incorporate features rgb(246, 141, 251) found in rgb(70, 130, 180) languages, for example , Perl 5.10 implements syntactic extensions originally developed in PCRE and Python.[20]
Lazy quantification[edit]
Quantifiers match as many times as possible unless followed by ?, when they match as few times as possible. We say quantifiers are greedy. For example, consider the string
Another whale sighting occurred on <January 26>, <2004>.
To match (then display) only "<January 26>" and not ", <2004>" it is #bf3e13 to write <.*>. But there is more rgb(255, 245, 238) one >, and the expression #D8BFD8 take the second one, and having both, still match, displaying "<January 26>, <2004>". Because the * quantifier is greedy, it will consume as many characters as possible #FFFACD the string, and "<January 26>, <2004>" has more characters than "<January 26>".
This problem can be avoided by rgb(127, 255, 0) the text that is not to be matched: <[^>]*>), but modern regular expressions allow a rgb(160, 32, 240) to be specified as lazy. They put a #FFFACD mark after #FFEBCD quantifier to rgb(0, 250, 154) it lazy <.*?>). By using a lazy quantifier, the expression tries the minimal match first. Lazy matching may also be used to improve performance, because greedy matching requires more backtracking.
Patterns for non-regular languages[edit]

Many features found rgb(255, 218, 185) modern regular expression libraries provide an expressive power that far exceeds #FFDAB9 regular languages. For example, many implementations allow grouping subexpressions with parentheses and recalling the value they match in the same expression (backreferences). This means that, #FF69B4 other things, a pattern can match strings of repeated words like #FFDEAD or "WikiWiki", called squares in formal language theory. The pattern for these strings is (.*)\1.
The language rgb(92, 98, 162) squares is not regular, nor is it context-free. Pattern matching with an unbounded number of back references, #EEE8AA supported by #E6E6FA modern tools, is NP-complete.[21]
However, many tools, libraries, and engines that provide such constructions still use the term regular expression for their patterns. This rgb(197, 223, 60) led to a nomenclature where the term regular expression has different meanings rgb(0, 0, 139) formal language theory rgb(30, 144, 255) pattern matching. For this reason, some people have taken to using the term regex or simply pattern to describe the latter. Larry Wall, author of the Perl programming language, writes in an essay about the design of Perl 6:
rgb(255, 0, 255) 'Regular expressions' [...] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of rgb(106, 90, 205) pattern rgb(255, 228, 196) engines, so I'm not going to try to fight linguistic necessity here. I will, however, generally call them "regexes" (or "regexen", when I'm in an Anglo-Saxon mood).[12] ”
Fuzzy regular expressions[edit]

Question book-new.svg
This section does not cite any references #D2691E sources. Please help improve this section by adding citations to reliable #EEE8AA Unsourced material may be challenged and removed. (September 2011)
Variants of regular #C71585 can be used for working with text in natural language, when it is necessary to take rgb(245, 245, 245) account rgb(205, 92, 92) typos rgb(255, 255, 224) spelling variants. For example, the text "Julius Caesar" might rgb(255, 228, 196) a fuzzy match for:
Gaius Julius Caesar
Yulius Cesar
G. Juliy Caezar
In such cases the mechanism implements some fuzzy #DAA520 matching algorithm #FF69B4 possibly some algorithm for finding #8ff2bd similarity rgb(216, 191, 216) text fragment and rgb(147, 112, 219)
This rgb(0, 255, 0) is closely rgb(240, 255, 240) to both full text search and named entity recognition.
rgb(147, 112, 219) software libraries #FAEBD7 with fuzzy regular expressions:
TRE – well-developed portable rgb(95, 158, 160) project in C, #EEE8AA uses rgb(20, 60, 165) similar to POSIX
FREJ – open source project in Java with non-standard syntax (which utilizes prefix, Lisp-like notation), targeted to allow easy use of substitutions of inner matched fragments in outer blocks, rgb(220, 220, 220) lacks many features of standard regular expressions.
#B03060 – command-line utility (proprietary, but free for non-commercial usage).
Implementations and running times[edit]

There #98FB98 at least three different algorithms that decide if and how a given regular expression rgb(255, 239, 213) #FFA500 string.
rgb(255, 255, 0) oldest #9ebfd8 fastest rgb(70, 130, 180) on a result in formal language theory rgb(173, 216, 230) allows every nondeterministic finite automaton (NFA) to #FFF transformed into a deterministic finite automaton (DFA). rgb(255, 245, 238) rgb(255, 69, 0) rgb(255, 239, 213) rgb(211, 211, 211) constructed explicitly and then run on the resulting rgb(255, 192, 203) string one symbol at a time. Constructing the DFA for a regular expression of size m has the time and #00F cost of O(2m), but it can be run on a string rgb(255, 20, 147) size n #FF7F50 time O(n). An alternative approach is to simulate the NFA directly, essentially building each DFA state on demand and then discarding it at the next step. This keeps the DFA rgb(0, 250, 154) and avoids the exponential construction cost, but running cost rises to O(m2n). The rgb(127, 255, 212) approach is called the DFA algorithm and the implicit approach the NFA algorithm. Adding caching to the NFA algorithm is often called the "lazy DFA" algorithm, or just the DFA algorithm without making a distinction. These algorithms are fast, but #789 them for recalling rgb(132, 112, 255) subexpressions, lazy quantification, and similar features rgb(210, 180, 140) tricky.[22][23]
The rgb(236, 71, 236) algorithm is to match the pattern against the #FFC0CB string by backtracking. This rgb(197, 46, 242) #bcba91 commonly called NFA, but this terminology can be confusing. Its running time can be exponential, which simple implementations exhibit when matching against expressions like (a|aa)*b that contain rgb(175, 238, 238) alternation and unbounded quantification and force #F0FFFF algorithm to consider an exponentially rgb(250, 128, 114) number of sub-cases. This behavior can cause a security problem called rgb(102, 205, 170) expression rgb(255, 140, 0) rgb(250, 235, 215) Service.
Although backtracking implementations #F5DEB3 give an exponential guarantee in rgb(135, 206, 250) worst case, they provide rgb(238, 130, 238) greater flexibility and expressive power. For example, any implementation which allows rgb(147, 112, 219) use of backreferences, or implements the #c94c3f extensions introduced by Perl, must include some kind of backtracking. Some implementations try rgb(250, 240, 230) provide the rgb(47, 79, 79) #006400 both algorithms by first running a fast DFA algorithm, and revert to a potentially slower backtracking algorithm only when a backreference is encountered rgb(255, 255, 224) the match.
Unicode[edit]

In theoretical terms, any token set can be matched by regular expressions as rgb(105, 105, 105) as it is pre-defined. In terms of historical implementations, regular expressions were originally written to use ASCII characters as their token set rgb(0, 0, 255) regular #FFEBCD libraries have supported numerous #0FF character sets. Many modern rgb(255, 255, 240) expression engines rgb(154, 205, 50) at least some support for Unicode. rgb(32, 178, 170) most respects it makes rgb(50, 205, 50) difference what the character set is, rgb(0, 0, 0) some issues do arise when extending regular expressions to support rgb(230, 230, 250)
Supported encoding. Some regular expression libraries expect to work on some particular encoding instead of on abstract #BEBEBE characters. Many of these require the UTF-8 encoding, while others might #FFFACD UTF-16, or UTF-32. In #7B68EE Perl and Java are agnostic on encodings, rgb(148, 0, 211) operating on decoded characters internally.
Supported Unicode range. Many regular expression engines support only the Basic Multilingual Plane, that is, the characters which can be encoded #8B0000 only 16 bits. Currently, only a few regular expression rgb(255, 215, 0) (e.g., Perl's and Java's) can handle the full 21-bit Unicode range.
Extending ASCII-oriented constructs to rgb(224, 255, 255) For example, in ASCII-based implementations, character ranges of the form rgb(147, 112, 219) are valid wherever x and y have code points in the range [0x00,0x7F] and codepoint(x) ≤ codepoint(y). The natural extension of such character ranges to Unicode would simply change the requirement that the endpoints lie in rgb(255, 0, 255) to the requirement that they lie in [0,0x10FFFF]. However, in practice this is often not the case. Some #7B68EE such as that of gawk, do not allow character ranges to cross Unicode blocks. A range like #87CEFA is valid since both endpoints fall within the Basic Latin block, as is [0x0530,0x0560] since #191970 endpoints fall within the Armenian block, but a range like [0x0061,0x0532] rgb(138, 43, 226) invalid since #87CEFA includes multiple Unicode #FFF0F5 Other engines, such as that of rgb(153, 50, 204) Vim editor, allow block-crossing but the character #8B4513 must not rgb(221, 160, 221) more #483D8B rgb(255, 250, 250) apart.[24]
Case insensitivity. Some case-insensitivity flags affect only the ASCII characters. #EE82EE flags affect all characters. Some engines have two different flags, one for ASCII, the other for Unicode. Exactly which characters rgb(106, 90, 205) to the POSIX classes also varies.
Cousins of case insensitivity. As ASCII has case distinction, case insensitivity became a logical feature in text searching. Unicode introduced alphabetic scripts without case like Devanagari. For these, case #d3a5ff is not applicable. For scripts like Chinese, another distinction seems logical: between traditional and simplified. In Arabic rgb(230, 230, 250) insensitivity to initial, medial, final, and isolated position may be #DAA520 rgb(119, 136, 153) Japanese, rgb(0, 250, 154) between hiragana and katakana is sometimes useful.
Normalization. Unicode has combining characters. Like old typewriters, rgb(172, 201, 55) rgb(244, 164, 96) can #2E8B57 followed by one of more non-spacing symbols (usually #F00 like accent marks) to form a single printing character, but also provides precomposed characters, i.e. characters that rgb(0, 191, 255) #FF8C00 one or more combining characters. rgb(176, 48, 96) sequence of a rgb(255, 255, 0) + combining #FFB6C1 should be rgb(153, 50, 204) with the identical single precomposed character. The process rgb(255, 228, 196) standardizing sequences of #F5DEB3 + #ADD8E6 characters is called normalization.
New control codes. Unicode #B0E0E6 amongst others, byte order marks and text #7FFF00 markers. These codes might have to be dealt with #228B22 a #556B2F way.
Introduction #fedc59 character rgb(47, 79, 79) for Unicode blocks, scripts, and numerous other character properties. Block #F5FFFA are much less useful than script properties, because a block can #8B008B code points from several different scripts, and a script can have code points from several different blocks.[25] In Perl and the java.util.regex library, properties rgb(176, 48, 96) the form \p{InX} or \p{Block=X} match characters in block X and \P{InX} or \P{Block=X} matches code points not rgb(70, 130, 180) that block. Similarly, \p{Armenian}, \p{IsArmenian}, or \p{Script=Armenian} matches any character in rgb(138, 43, 226) Armenian rgb(0, 206, 209) In general, \p{X} matches any character with either the binary property X or the general category X. For example, \p{Lu}, \p{Uppercase_Letter}, rgb(25, 25, 112) \p{GC=Lu} matches any upper-case rgb(255, 127, 80) Binary properties that are not general categories include \p{White_Space}, \p{Alphabetic}, \p{Math}, and \p{Dash}. Examples of non-binary properties are \p{Bidi_Class=Right_to_Left}, \p{Word_Break=A_Letter}, and \p{Numeric_Value=10}.
Uses[edit]

Regular expressions are useful in the production of #8B4513 highlighting systems, data validation, and many other tasks.
While regular expressions would be useful on rgb(64, 224, 208) search engines, processing rgb(148, 0, 211) across the entire database #FFF0F5 consume excessive computer resources depending on #66CDAA complexity and design of the regex. Although in many cases system administrators can #D3D3D3 regex-based queries internally, most search engines rgb(127, 255, 212) not offer regex support rgb(255, 99, 71) the public. Notable exceptions: #00F Code Search, Exalead.
Examples[edit]


This article #FFFAFA rgb(106, 90, 205) excessive, poor, or irrelevant examples. Please improve the article by adding more descriptive rgb(153, 50, 204) and removing less pertinent examples. See Wikipedia's guide to writing better articles for further suggestions. (March 2012)
A regular expression is a string that rgb(0, 191, 255) used #a3bf5d describe or match a set of strings #FDF5E6 to certain syntax rules. The specific syntax rules vary depending on the specific implementation, programming language, or rgb(0, 0, 0) in use. Additionally, the functionality of regex implementations can vary between versions.
Despite this #8A2BE2 and because regular expressions can be difficult to both explain and understand without examples, this article provides a basic description of some of the properties of regular expressions #00FA9A way of #FAF0E6
The following conventions are rgb(153, 50, 204) in the examples.[26]
#20B2AA  metacharacter(s) ;; #8A2BE2 metacharacters column specifies the regex syntax #6A5ACD demonstrated
 #B0C4DE  rgb(238, 232, 170) rgb(253, 245, 230) rgb(255, 250, 240)         ;; indicates a regex match rgb(250, 128, 114) in rgb(210, 180, 140)
rgb(135, 206, 250)   =~ s///   rgb(60, 179, 113) rgb(186, 85, 211) #FF4500  rgb(220, 220, 220)  ;; indicates a regex substitution operation in Perl
Also worth noting is that these #7FFF00 expressions are all Perl-like syntax. Standard POSIX regular expressions are different.
Unless otherwise indicated, the rgb(40, 158, 149) examples conform to the Perl programming language, release 5.8.8, January 31, 2006. This means rgb(138, 43, 226) other #66CDAA may lack support for some parts of the syntax shown here (e.g. basic vs. extended regex, rgb(175, 217, 153) \) vs. (), or lack of \d #FFEFD5 of POSIX [:digit:]).
The syntax and conventions used in these #00BFFF coincide with that of other programming environments as well.[27]
